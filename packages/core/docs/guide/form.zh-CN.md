# 表单模型

前面讲到了 Formily 内核的整体架构，同时也讲了 MVVM，你应该也能大致能理解什么是 Formily 的表单模型了，下面我们再深一步来讲表单模型的具体领域逻辑，主要是偏思路性的总结性内容，如果第一遍看不懂，可以先直接去看 API 文档，看完之后再回来看，就能加深对 formily 的理解了。

## 梳理

整个表单模型很大很复杂，分解下来其实核心是以下几个子模型：

- 字段管理模型
- 字段模型
- 数据模型
- 联动模型
- 路径系统

下面具体来讲一下表单模型是如何管理的。

## 字段管理模型

字段管理模型，主要包含：

- 字段添加
- 字段查询
- 导入字段集
- 导出字段集
- 清空字段集

#### 字段添加

主要通过 createField/createArrayField/createObjectField/createVoidField 方法来创建字段，如果字段已经存在，则不会重复创建

#### 字段查询

主要通过 query 方法来查询字段，query 方法可以传入字段的路径或者正则表达式来匹配字段。

因为字段路径的详细规则还是比较复杂的，在后面的[路径系统](/guide/path)篇中会详细讲解。

然后调用 query 方法会返回一个 Query 对象，Query 对象中可以有批量遍历所有字段的 forEach/map/reduce 方法，也可以有只取查询到的第一个字段的 take 方法，同时还有直接读取字段属性的 get 方法，还有可以深层读取字段属性的 getIn 方法，两个方法的差别就是前者可以有智能提示，后者没有提示，所以推荐用户都用 get 方法。

#### 导入字段集

主要通过 setFormGraph 来导入字段集，入参格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，使用该 API 主要在一些需要做时间旅行的场景，将 Immutable 字段状态导入至表单模型中。

#### 导出字段集

主要通过 getFormGraph 来导出字段集，导出格式是一个扁平对象格式，key 是字段的绝对路径，value 是字段的状态，与导入字段集入参一致，因为返回的数据是一个 Immutable 的数据，所以是可以完全做持久化存储的，方便时间旅行。

#### 清空字段集

主要通过 clearFormGraph 来清空字段集。

## 字段模型

字段模型主要包含了：

- Field 模型，主要负责管理非自增型字段状态，比如 Input/Select/NumberPicker/DatePicker 这些组件
- ArrayField 模型，主要负责管理自增列表字段状态，可以对列表项进行增删移动的。
- ObjectField 模型，主要负责管理自增对象字段状态，可以对对象的 key 做增删操作。
- VoidField 模型，主要负责管理虚字段状态，虚字段是一种不会污染表单数据的节点存在，但是它可以控制它的子节点显示隐藏，交互模式。

因为字段模型非常复杂，所以会在后面的[字段模型](/guide/field)篇中详细讲解。

## 数据模型

表单数据模型，formily 之前的版本或多或少都会存在一些边界问题，在 2.x 中重新梳理了一版，才真正把之前的遗留问题突破掉了。

数据模型主要包含：

- 表单值(values)管理
- 表单默认值(initialValues)管理
- 字段值(value)管理
- 字段默认值(initialValue)管理
- 值与默认值的选择合并策略

表单值管理，其实就是一个对象结构的 values 属性，只是它是一个 @formily/reactive observable 属性，同时借助了 @formily/reactive 的深度 observer 能力，监听了它任意属性变化，如果发生变化，便会触发 onFormValuesChange 的生命周期钩子。

同理，默认值管理其实也是一个对象结构的 initialValues 属性，同样会深度监听属性变化，触发 onFormInitialValues 的生命周期钩子。

字段值管理，是在每个数据型字段的 value 属性上体现的，formily 会给每个字段维护一个叫 path 的数据路径属性，然后 value 的读写，都是对顶层表单的 values 进行读写，这样保证了字段的值与表单的值是绝对幂等的，同理字段默认值也一样。

总结一下，**值的管理，都是在顶层表单上管理的，字段的值与表单的值是通过 path 来实现的绝对幂等。**

<Alert>

值与默认值的差别其实就在于表单重置的时候，字段是否会重置为默认值状态

</Alert>

#### 值与默认值的选择合并策略

平时我们在业务开发的过程中，总会有数据回显的需求，这份数据一般都是作为异步默认值，作为详情页面的话，都还好，但是作为编辑页面的话，就会存在一些问题了：

**存在冲突**

比如表单值为`{xx:123}`，表单默认值为`{xx:321}`，这里的策略是：

- 如果`xx`没有相应的字段模型，代表仅仅只是冗余数据，用户无法修改
  - 如果表单值是先赋值，默认值是后赋值的，那么默认值直接覆盖表单值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据`{xx:321}`
  - 如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据`{xx:123}`
- 如果`xx`有字段模型
  - 如果表单值先赋值，默认值是后赋值的
    - 如果当前字段被用户修改过(modified 为 true)，那么默认值不能覆盖表单值，最终提交数据`{xx:123}`
    - 如果当前字段没有被用户修改过(modified 为 false)，那么默认值会直接覆盖字段值，这种场景适用于异步数据回显场景，不同业务状态，回显的默认数据不一样，最终提交数据`{xx:312}`
  - 如果默认值先赋值，表单值是后赋值的，那么表单值直接覆盖默认值，这种场景适用于同步默认值，最终提交数据`{xx:123}`

**不存在冲突**

比如表单值为`{xx:123}`，表单默认值为`{yy:321}`，这里的策略是直接合并。

总结一下，值与默认值的选择合并策略，**核心是看该字段是否被用户修改过，一切以用户为准，如果没被用户修改过就以赋值顺序为准**

<Alert>

这里提到的默认值，是可以重复赋值的，说的也是在重复赋值的过程中，要不要舍弃值的问题。

</Alert>

## 校验模型

表单校验模型核心是对数据的合法性校验，然后将校验结果管理起来，所以校验模型主要包含了：

- 校验规则管理
- 校验结果管理

因为校验模型隶属于字段模型，所以会在后面的[字段模型](/guide/field#校验规则)篇中详细讲解

## 联动模型

联动模型在 formily1.x 中核心是走的主动式联动模型，大致用一句表达式来表达就是：

```ts
setFieldState(Subscribe(FormLifeCycle, Selector(Path)), TargetState)
```

解释下就是，任意一次联动，都是基于表单的某个生命周期钩子去触发指定路径下字段的状态，这样的模型能解决很多问题，但是它也有个很明显的问题，就是在多对一联动的场景下，需要同时监听多个字段变化去控制某个字段的状态，这样对用户而言，实现成本还是比较高的，特别是实现一些计算器联动需求，代码量剧增。当然，对于一对多场景，反而这种模型又是最高效的。

所以，在 formily2.x 中，在主动联动模型上新增了被动联动模型，同样是一句表达式表达：

```ts
subscribe(Dependencies, Reactions)
```

简化了很多，核心就是针对依赖数据变化做响应，依赖的数据可以是表单模型属性，也可以是任意字段模型的属性，响应的动作可以是改任意字段模型的属性，也可以是做其他异步动作。这样的模型同样是一个完备的联动模型，只是在一对多场景下，比起主动模型而言，实现成本会比较高。

所以，两种联动模型，需要用户根据自身需求来选择。

## 路径系统

路径系统，非常重要，几乎整个表单模型处处都有用到路径系统，它的主要给表单模型提供了以下几个能力：

- 它可以用来从字段集中查找任意一个字段，同时支持按照规则批量查找
- 它可以用来表达字段间关系的模型，借助路径系统，我们可以实现查找某个字段父亲，能查找父亲，也就能实现树级别的数据继承能力，同样，我们也能查找某个字段的相邻节点
- 它可以用来实现字段数据的读写，带解构的数据读写

整个路径系统，其实是基于@formily/path 的路径 DSL 来实现的，想要了解更多路径系统的内容，可以详细看看[FormPath API](/api/entry/form-path)篇
